# DDD

> Domain-Driven Design is **an approach to software development that centers the development on programming a domain model that has a rich understanding of the processes and rules of a domain.** 
> 
>  Eric Evans
>


# WHY

- Put domain experts and developers on a level playing field, which produces software that makes perfect sense to the business, not just the coders
- Ubiquitous language: having the same language for everyone in the company
- DDD provides software development techniques that address both strategic and tactical design
    - Strategic design: helps us understand what are the most important software investments to make, what existing software assets to leverage in order to get there fastest and "safest", and who must be involved.
    - The tactical, technical aspect of DDD guides the implementation process with the fundamental purpose of protecting the model from corruption. The patterns and architectural structures commonly associated with DDD (though not necessarily first invented or discovered by DDD) flow naturally from this constraint, to provide the requisite layers of protection.
- Questions that helps to understand the process of the company and the company understand their processes
- Software economics = Make Better-informed Development Decisions, Increase Developer Productivity, allocate resources wisely, improve release frequency and predictability, deliver quality and more durable product

## Ubiquitous language

Why is so important?

The Ubiquitous Language is developed with full team agreement, is spoken, and is directly captured in the model of the software. It is worth reiterating that the team is comprised of both domain experts and software developers. It's never “us and them.” It's always **us**.

### **Bounded Contexts**

Bounded context is the context in which the ubiquitous language and the corresponding models are valid. It gives the team a clear understanding of what has to be consistent and what can be developed independently.

## DDD Philosophy

DDD talks a lot about the ubiquitous language of a domain (also called the domain language). Ubiquity is a goal, a guide, and the central organising theme. Everyone, technical and nontechnical, must speak the same language, use the same terms, and give the same names to the same concepts.

The strategic, tactical, and technical aspects of DDD are intended to support and enforce this philosophy

## Conclusions

### DDD It's **a journey, not a destination**

Having a model-domain harmony never ends, as long as the business keeps changing. But it's alright, because DDD is a continuous process. It keeps the guardrails up, the feedback flowing, and the software on track with the business. DDD does this strategically, tactically, and philosophically.

### It's hard and it's not for every company

In many ways this is why DDD is considered hard to do right and it's complex: 

- it takes discipline to adhere to the philosophy. Lot of times you will struggle thinking if you are doing it wrong
- you will have to keep asking "What does this really mean?" and "Why does this happen?"until the deeper model is uncovered.
- it requires patience to keep refining, refactoring, iterating, and accepting feedback until the model, the code, and the business coalesce into a cooperative synergy.

## Just start!

- It's never late.
